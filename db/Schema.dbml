table organizations {
  id int [ pk, not null, increment ]
  name varchar [ not null, unique]
  logo text [note: "Logo url"]
  created_on timestamp [not null, default: `now()`]
  updated_on timestamp [not null, default: `now()`, note: 'TODO: Add ON UPDATE ON UPDATE CURRENT_TIMESTAMP']
}

// Emissions Control Area (ECA)
table ecas {
  id int [ pk, not null, increment ]
  lon float [not null]
  lat float [not null]
  name varchar [not null, note: 'Following zones exist: "hawaiian islands", "northeurope", "northamericanatlantic", "northamericanpacific", "usacaribbean"']
}

table ports {
  id int [ pk, not null, increment ]
  name varchar [not null, unique]
  created_on timestamp [not null, default: `now()`]
  updated_on timestamp [not null, default: `now()`, note: 'TODO: Add ON UPDATE ON UPDATE CURRENT_TIMESTAMP']
}

// maybe stick to an enum on user for simplification?
table roles { 
  id int [ pk, not null, increment ]
  role_name varchar [not null, note: 'operator Operators have access to viewing vessels belonging to the company the user is associated with, as well as creating new voyages. admin: Admins have the same access as operators, but in addition to that they can create new users. super_user:  Super users have the same access as admins, but in addition to that they can create admin users.'] 
  created_on timestamp [not null, default: `now()`]
  updated_on timestamp [not null, default: `now()`, note: 'TODO: Add ON UPDATE ON UPDATE CURRENT_TIMESTAMP']
}

// To determine the current selected route find the latest selected route
table selected_routes {
  fk_voyage_id int [note: 'TODO: Create composite key']
  fk_route_id int [note: 'TODO: Create composite key']
  created_on timestamp [not null, default: `now()`, note: 'TODO: Create composite key']
  // Selected routes are edited by creating a new record so there is not updated_on column.
}

table users { 
  id int [ pk, not null, increment ]
  name varchar [ not null ]
  confirmed boolean [note: 'Has user confirmed email address?']
  email varchar [ unique, not null ]
  fk_role_id int [not null]
  fk_company_id int
  created_on timestamp [not null, default: `now()`]
  updated_on timestamp [not null, default: `now()`, note: 'TODO: Add ON UPDATE ON UPDATE CURRENT_TIMESTAMP']
}

table favorite_vessels {
  user_id integer [note: 'TODO: Make composite key']
  vessel_id integer [note: 'TODO: Make composite key']
  created_on timestamp [not null, default: `now()`]
}


// routes are suggested routes generated by the ov algorithm and are associated with a number of waypoints.
// routes 
table routes {     
  id int [ pk, not null, increment ]
  fk_id_voyage int
  // ETA in UTC
  eta datetime [not null]
  // Estimated sailtime
  sailtime float [not null]
  // maximum wave height in meters
  max_wave_height float [not null]
  // Estimated HFO consumption for given route (tons)
  hfo float [not null]
  // Estimated LSFO consumption for given route (tons)
  lsfo float [not null]
  // Total estimated cost of the voyage = current hirerate * (ETA - ETD in days) + current consumption + estimated consumption
  total_cost float [not null]
  // distance over ground in nautical mile
  distance_over_ground float [not null]
  // distance through water in nautical mile
  distance_through_water float [not null]
  // average speed in knots         
  avgspeed float [not null]
  created_on timestamp [not null, default: `now()`]
  updated_on timestamp [not null, default: `now()`, note: 'TODO: Add ON UPDATE ON UPDATE CURRENT_TIMESTAMP']
}

table vessels {
  id int [ pk, not null, increment ]
  fk_id_company int
  // Maritime Mobile Service Identity (MMSI) is used to uniquely identify ships over radio
  mmsi          numeric [not null, unique]
  name          varchar [not null, unique]
  created_on timestamp [not null, default: `now()`]
  updated_on timestamp [not null, default: `now()`, note: 'TODO: Add ON UPDATE ON UPDATE CURRENT_TIMESTAMP']
}

// Previously named "noonreport". Daily report from the captain to the company and optimum voyage
table vessel_reports {
  id int [ pk, not null, increment ]
  fk_vessel_id int
  // References waypoint id
  position int
  current_speed float [not null]
  // How much HFO was consumed since last report
  hfo_consumption float [not null]
  // How much LSFO was consumed since last report
  lsfo_consumption float [not null]
  // Exact time the report was made in UTC
  created_on timestamp [not null, default: `now()`]
  // Vessel reports can never be changed retrospectively, so there is no updated_on column.
}

table voyages {
  id int [ pk, not null, increment ]
  // To get the ship/vessel name
  fk_id_vessel int
  etd datetime [not null, note: 'Estimate time of departure']
  eta datetime [not null, note: 'Estimate time of arrival']
  forwarddraft float [not null, note: 'Forward draft in meters. Measured perpendicular of the bow.']
  aftdraft float [not null, note: 'Aft draft in meters. Measured perpendicular to the stern.']
  optimisation_type optimisation_types [ not null, default: 'least_cost_arrival' ]
  depart_from int [ not null, note: 'Departure waypoint']
  arrive_at int [ not null, note: 'Arrival waypoint']
  sailtime float [ not null, default: 0, note: 'Sailtime in hours']
  hfocost float [ not null, default: 0, note: 'Heavy Fuel Oil (HFO) cost in US dollars.']
  lsfocost float [ not null, default: 0, note: 'Low Sulfor Fuel Oil (LSFO) cost in US dollars.' ]
  hirerate float [note: 'Hire rate per day. Optional, must only be filled out if the vessel is chartered.']
  status voyage_status [not null, default: 'created' ]
  created_on timestamp [not null, default: `now()`]
  updated_on timestamp [not null, default: `now()`, note: 'TODO: Add ON UPDATE ON UPDATE CURRENT_TIMESTAMP']
}

table waypoints {
  id int [ pk, not null, increment ]
  fk_route_id int
  fk_port_id int
  sequence_id int     // counts from 0 and up every time a new set of waypoints is added to a route
  lon float [ not null ]
  lat float [ not null ]
  created_on timestamp [not null, default: `now()`]
  updated_on timestamp [not null, default: `now()`, note: 'TODO: Add ON UPDATE ON UPDATE CURRENT_TIMESTAMP']
}

enum optimisation_types {
  fixed_eta [ note: 'Optimise for the cheapest route given a fixed arrival time.' ]
  least_cost_arrival [ note: 'Optimise for the cheapest possible trip overall.' ]
  earliest_arrival [ note: 'Optimise for fastest possible arrival.' ]
}


enum voyage_status {
  created [ note: 'New voyage has been created, but no reports received yet.' ]
  ongoing [ note: 'Vessel is currently en route.' ]
  completed [ note: 'Vessel has reached destination.' ]
}


// A user has 1 role
ref: roles.id < users.fk_role_id

// A company has 0-* users
ref: organizations.id < users.fk_company_id
// A vessel has 0-* voyages
ref: vessels.id < voyages.fk_id_vessel
// A voyage has 0-* routes
ref: voyages.id < routes.fk_id_voyage
// A route has 1-* waypoints
ref: routes.id < waypoints.fk_route_id
// A port has 1-* waypoints
ref: ports.id < waypoints.fk_port_id
// A company has 0-* vessels
ref: organizations.id < vessels.fk_id_company
// A vessel has 0-* vessel_reports
ref: vessels.id < vessel_reports.fk_vessel_id
// A voyage has 1 departure waypoint
ref: voyages.depart_from > waypoints.id
// A voyage has 1 arrival waypoint
ref: voyages.arrive_at > waypoints.id
// A waypoint may belong to 0-* vessel reports
ref: waypoints.id < vessel_reports.position 
// Selected route represents a many-to-many join table between route and voyage
// Current selected route is found by looking for the latest record
ref: routes.id < selected_routes.fk_route_id
ref: voyages.id < selected_routes.fk_voyage_id
ref: favorite_vessels.user_id > users.id
ref: favorite_vessels.vessel_id > vessels.id
